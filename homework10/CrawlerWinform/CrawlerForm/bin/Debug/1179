<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta property="og:description" content="在前边的博客中分析了mybatis解析properties标签，《mybatis源码配置文件解析之一：解析properties标签》。下面来看解析settings标签的过程。 一、概述 在mybati" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>mybatis源码配置文件解析之二：解析settings标签 - 迷茫中守候 - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=-oFz8B4m7JhHaZzdTkzPza2oLZNDRR8obnCz6w7OHbU" />
    <link id="MainCss" rel="stylesheet" href="/skins/lessismore/bundle-lessismore.min.css?v=zIJHCVIW8ogRcUFVWHfM_7E_wChBUrXPbKFNppkseEg" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/lessismore/bundle-lessismore-mobile.min.css?v=ADiCwO2hOTdd5yYidcx7eob7ix2VJI4o_TXjEycTHjs" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/teach/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/teach/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/teach/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=z6JkvKQ7L_bGD-nwJExYzsoFf5qnluqZJru6RsfoZuM"></script>
    <script>
        var currentBlogId = 293786;
        var currentBlogApp = 'teach';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'LessIsMore';
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    
    <div id="home">
    <div id="header">
        <div id="blogTitle">
            
<div class="title"><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/teach/">迷茫中守候</a>
</div>
<div class="subtitle">

</div>

        </div>
        <div id="navigator">
            
<ul id="navList">
    <li id="nav_sitehome"><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
    <li id="nav_myhome">
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/teach/">
首页</a>
</li>
    <li id="nav_newpost">

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
    <li id="nav_contact">
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E8%BF%B7%E8%8C%AB%E4%B8%AD%E5%AE%88%E5%80%99">
联系</a></li>
    <li id="nav_rss">
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/teach/rss/">
订阅</a></li>
    <li id="nav_admin">
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>

            <div class="blogStats">
                
<span id="stats_post_count">随笔 - 
61&nbsp;</span>
<span id="stats_article_count">文章 - 
0&nbsp;</span>
<!-- <span id="stats-comment_count"></span> -->
<span id="stats_comment_count">评论 - 
49</span>
            </div>
        </div>
    </div>
    <div id="main">
        <div id="mainContent">
            <div class="forFlow">
                <div id="post_detail">
    <div id="topics">
        <div class="post">
            <h1 class="postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/teach/p/12753756.html">mybatis源码配置文件解析之二：解析settings标签</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body ">
    <p>在前边的博客中分析了mybatis解析properties标签，《<a class="postTitle2" href="https://www.cnblogs.com/teach/p/12693588.html">mybatis源码配置文件解析之一：解析properties标签</a>》。下面来看解析settings标签的过程。</p>
<h1>一、概述</h1>
<p>在mybatis的核心配置文件（mybatis-config.xml）文件中，有关于settings标签的配置，如下</p>
<div class="cnblogs_code">
<pre>&lt;settings&gt;
        &lt;!-- 设置日志输出为LOG4J --&gt;
        &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt;
        &lt;!--将以下画线方式命名的数据库列映射到 Java 对象的驼峰式命名属性中--&gt;
        &lt;setting name= "mapUnderscoreToCamelCase" value="true" /&gt;
    &lt;/settings&gt;</pre>
</div>
<p>上面只简单的给出settings标签的配置，settings标签配置在&lt;configuration&gt;标签中，是&lt;configuration&gt;标签的子标签。在settings标签中可以配置setting子标签，上面是我的一个配置，是以name-value键值对的放式进行配置。这里有个问题setting标签中的name怎么配置，共有多少配置？</p>
<h1>二、详述</h1>
<p>上面，看到了settings标签的配置方式，下面看其解析过程，在XMLConfigBuilder类中的parseConfiguration方法中有关于该标签的解析，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> parseConfiguration(XNode root) {
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
      </span><span style="color: #008000;">//</span><span style="color: #008000;">issue #117 read properties first
      </span><span style="color: #008000;">//</span><span style="color: #008000;">解析properties标签    </span>
      propertiesElement(root.evalNode("properties"<span style="color: #000000;">));
      </span><span style="color: #008000;">//</span><span style="color: #008000;">解析settings标签，1、把&lt;setting&gt;标签解析为Properties对象</span>
      Properties settings = settingsAsProperties(root.evalNode("settings"<span style="color: #000000;">));
      </span><span style="color: #008000;">/*</span><span style="color: #008000;">2、对&lt;settings&gt;标签中的&lt;setting&gt;标签中的内容进行解析，这里解析的是&lt;setting name="vfsImpl" value=","&gt;
      * VFS是mybatis中用来表示虚拟文件系统的一个抽象类，用来查找指定路径下的资源。上面的key为vfsImpl的value可以是VFS的具体实现，必须
      * 是权限类名，多个使用逗号隔开，如果存在则设置到configuration中的vfsImpl属性中，如果存在多个，则设置到configuration中的仅是最后一个
      * </span><span style="color: #008000;">*/</span><span style="color: #000000;">
      loadCustomVfs(settings);
      </span><span style="color: #008000;">//</span><span style="color: #008000;">解析别名标签，例&lt;typeAlias alias="user" type="cn.com.bean.User"/&gt;</span>
      typeAliasesElement(root.evalNode("typeAliases"<span style="color: #000000;">));
      </span><span style="color: #008000;">//</span><span style="color: #008000;">解析插件标签</span>
      pluginElement(root.evalNode("plugins"<span style="color: #000000;">));
      </span><span style="color: #008000;">//</span><span style="color: #008000;">解析objectFactory标签，此标签的作用是mybatis每次创建结果对象的新实例时都会使用ObjectFactory，如果不设置
      </span><span style="color: #008000;">//</span><span style="color: #008000;">则默认使用DefaultObjectFactory来创建，设置之后使用设置的</span>
      objectFactoryElement(root.evalNode("objectFactory"<span style="color: #000000;">));
      </span><span style="color: #008000;">//</span><span style="color: #008000;">解析objectWrapperFactory标签</span>
      objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"<span style="color: #000000;">));
      </span><span style="color: #008000;">//</span><span style="color: #008000;">解析reflectorFactory标签</span>
      reflectorFactoryElement(root.evalNode("reflectorFactory"<span style="color: #000000;">));
      settingsElement(settings);
      </span><span style="color: #008000;">//</span><span style="color: #008000;"> read it after objectFactory and objectWrapperFactory issue #631
      </span><span style="color: #008000;">//</span><span style="color: #008000;">解析environments标签</span>
      environmentsElement(root.evalNode("environments"<span style="color: #000000;">));
      databaseIdProviderElement(root.evalNode(</span>"databaseIdProvider"<span style="color: #000000;">));
      typeHandlerElement(root.evalNode(</span>"typeHandlers"<span style="color: #000000;">));
      </span><span style="color: #008000;">//</span><span style="color: #008000;">解析&lt;mappers&gt;标签</span>
      mapperElement(root.evalNode("mappers"<span style="color: #000000;">));
    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
      </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> BuilderException("Error parsing SQL Mapper Configuration. Cause: " +<span style="color: #000000;"> e, e);
    }
  }</span></pre>
</div>
<p>上面便是parseConfiguration方法，在此方法中下面的方法对settings进行了解析，</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">解析settings标签，1、把&lt;setting&gt;标签解析为Properties对象</span>
      Properties settings = settingsAsProperties(root.evalNode("settings"));</pre>
</div>
<p>调用settingsAsProperties方法，从方法名中可以看出要把settings标签中的内容解析到Proerties对象中，因为settings标签中是name-value的配置，刚好解析到Properties中以键值对的形式存储。下面是settingsAsProperties方法，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span><span style="color: #000000;"> Properties settingsAsProperties(XNode context) {
    </span><span style="color: #0000ff;">if</span> (context == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
      </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Properties();
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">把&lt;setting name="" value=""&gt;标签解析为Properties对象</span>
    Properties props =<span style="color: #000000;"> context.getChildrenAsProperties();
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Check that all settings are known to the configuration class</span>
    MetaClass metaConfig = MetaClass.forClass(Configuration.<span style="color: #0000ff;">class</span><span style="color: #000000;">, localReflectorFactory);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">如果获取的配置的&lt;setting name="" value=""&gt;信息，name不在metaConfig中，则会抛出异常
    </span><span style="color: #008000;">//</span><span style="color: #008000;">这里metaConfig中的信息是从Configuration类中解析出来的，包含set方法的属性
    </span><span style="color: #008000;">//</span><span style="color: #008000;">所以在配置&lt;setting&gt;标签的时候，其name值可以参考configuration类中的属性，配置为小写</span>
    <span style="color: #0000ff;">for</span><span style="color: #000000;"> (Object key : props.keySet()) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">从metaConfig的relector中的setMethods中判断是否存在该属性，setMethods中存储的是可写的属性，
        </span><span style="color: #008000;">//</span><span style="color: #008000;">所以这里要到setMethods中进行判断</span>
      <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">metaConfig.hasSetter(String.valueOf(key))) {
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> BuilderException("The setting " + key + " is not known.  Make sure you spelled it correctly (case sensitive)."<span style="color: #000000;">);
      }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> props;
  }</span></pre>
</div>
<h2>1、解析子标签</h2>
<p>解析子标签也就是settings标签中的setting标签，使用下面的方法进行解析，</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">把&lt;setting name="" value=""&gt;标签解析为Properties对象</span>
    Properties props = context.getChildrenAsProperties();</pre>
</div>
<p>调用了getChildrenAsProperties方法，</p>
<div class="cnblogs_code">
<pre> <span style="color: #0000ff;">public</span><span style="color: #000000;"> Properties getChildrenAsProperties() {
    Properties properties </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Properties();
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (XNode child : getChildren()) {
      String name </span>= child.getStringAttribute("name"<span style="color: #000000;">);
      String value </span>= child.getStringAttribute("value"<span style="color: #000000;">);
      </span><span style="color: #0000ff;">if</span> (name != <span style="color: #0000ff;">null</span> &amp;&amp; value != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        properties.setProperty(name, value);
      }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> properties;
  }</span></pre>
</div>
<p>该方法就是解析&lt;settings&gt;&lt;/settings&gt;标签中的&lt;setting&gt;&lt;/setting&gt;标签，取出标签中的name和value属性，存储到Properties对象中且返回。</p>
<p>我们再看上面的settingsAsProperties方法，调用上述getChildrenAsProperties方法获得Properties对象后又进行了其他操作。</p>
<h2>2、校验setting标签中的name值是否存在</h2>
<h3>2.1、获得setting标签中的所有name值</h3>
<p>在本文开篇提到一个问题，setting标签中的name值怎么配置，答案是可以参考mybatis的官方文档，在官方文档中有详细的解释，再有就是分析源码，继续往下看。</p>
<p>在settingsAsProperties方法中看下面一行代码，</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Check that all settings are known to the configuration class</span>
    MetaClass metaConfig = MetaClass.forClass(Configuration.<span style="color: #0000ff;">class</span>, localReflectorFactory);</pre>
</div>
<p>上面这行代码就解析了setting标签中的name可以配置的所有值。再看代码上的注释，是不是豁然开朗。该方法有两个参数，一个是Configuration.class，一个是localReflectorFactory，看localReflectorFactory，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> ReflectorFactory localReflectorFactory = <span style="color: #0000ff;">new</span> DefaultReflectorFactory();</pre>
</div>
<p>使用了DefaultReflectorFactory，看其默认构造方法</p>
<p><img src="https://img2020.cnblogs.com/blog/985599/202004/985599-20200422150934093-2111158736.png" alt=""></p>
<p>默认构造方法仅初始化了classCacheEnabled和relectorMap两个属性。后过来继续看MetaClass.forClass方法，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> MetaClass forClass(Class&lt;?&gt;<span style="color: #000000;"> type, ReflectorFactory reflectorFactory) {
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> MetaClass(type, reflectorFactory);
  }</span></pre>
</div>
<p>该方法返回的是一个MetaClass的对象，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> MetaClass(Class&lt;?&gt;<span style="color: #000000;"> type, ReflectorFactory reflectorFactory) {
    </span><span style="color: #0000ff;">this</span>.reflectorFactory =<span style="color: #000000;"> reflectorFactory;
    </span><span style="color: #0000ff;">this</span>.reflector =<span style="color: #000000;"> reflectorFactory.findForClass(type);
  }</span></pre>
</div>
<p>重点看reflectorFactory.findForClass方法，这里reflectorFactory是DefaultReflectorFactory的一个实例。下面是DefaultReflectorFactory的findForClass方法，</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">@Override
  </span><span style="color: #0000ff;">public</span> Reflector findForClass(Class&lt;?&gt;<span style="color: #000000;"> type) {
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (classCacheEnabled) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> synchronized (type) removed see issue #461</span>
      Reflector cached =<span style="color: #000000;"> reflectorMap.get(type);
      </span><span style="color: #0000ff;">if</span> (cached == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
        cached </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Reflector(type);
        reflectorMap.put(type, cached);
      }
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cached;
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
      </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> Reflector(type);
    }
  }</span></pre>
</div>
<p>上面方法中，重点看new Reflector(type)这句方法，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> Reflector(Class&lt;?&gt;<span style="color: #000000;"> clazz) {
    type </span>=<span style="color: #000000;"> clazz;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">解析默认的构造方法，及无参构造方法</span>
<span style="color: #000000;">    addDefaultConstructor(clazz);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">解析clazz中的get方法，这里的clazz指的是Configuration.class</span>
<span style="color: #000000;">    addGetMethods(clazz);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">解析clazz中的set方法，这里的clazz指的是Configuration.class</span>
<span style="color: #000000;">    addSetMethods(clazz);
    addFields(clazz);
    readablePropertyNames </span>= getMethods.keySet().toArray(<span style="color: #0000ff;">new</span><span style="color: #000000;"> String[getMethods.keySet().size()]);
    writeablePropertyNames </span>= setMethods.keySet().toArray(<span style="color: #0000ff;">new</span><span style="color: #000000;"> String[setMethods.keySet().size()]);
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String propName : readablePropertyNames) {
      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String propName : writeablePropertyNames) {
      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
  }</span></pre>
</div>
<p>此方法完成的功能是解析clazz（包含其父类）的构造方法、getXX方法、setXX方法、字段，通过一个类的Class对象获取。</p>
<p>addDefaultConstructor(clazz)如下，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> addDefaultConstructor(Class&lt;?&gt;<span style="color: #000000;"> clazz) {
      </span><span style="color: #008000;">//</span><span style="color: #008000;">获得该类的声明的构造方法</span>
    Constructor&lt;?&gt;[] consts =<span style="color: #000000;"> clazz.getDeclaredConstructors();
    </span><span style="color: #008000;">//</span><span style="color: #008000;">对构造方法进行循环</span>
    <span style="color: #0000ff;">for</span> (Constructor&lt;?&gt;<span style="color: #000000;"> constructor : consts) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">判断构造方法的参数是否为0，为0代表为默认的无参构造方法</span>
      <span style="color: #0000ff;">if</span> (constructor.getParameterTypes().length == 0<span style="color: #000000;">) {
          </span><span style="color: #008000;">//</span><span style="color: #008000;">如果是私有的（修饰符为private），这里需要设置可见。</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (canAccessPrivateMethods()) {
          </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            constructor.setAccessible(</span><span style="color: #0000ff;">true</span><span style="color: #000000;">);
          } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Ignored. This is only a final precaution, nothing we can do.</span>
<span style="color: #000000;">          }
        }
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (constructor.isAccessible()) {
          </span><span style="color: #0000ff;">this</span>.defaultConstructor =<span style="color: #000000;"> constructor;
        }
      }
    }
  }</span></pre>
</div>
<p>上面方法获得传入的Class对象所以构造方法，把默认的无参构造方法赋给defaultConstructor。</p>
<p>addGetMethods(clazz)如下，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> addGetMethods(Class&lt;?&gt;<span style="color: #000000;"> cls) {
    Map</span>&lt;String, List&lt;Method&gt;&gt; conflictingGetters = <span style="color: #0000ff;">new</span> HashMap&lt;String, List&lt;Method&gt;&gt;<span style="color: #000000;">();
    </span><span style="color: #008000;">//</span><span style="color: #008000;">使用反射的放上获得cls的所有方法</span>
    Method[] methods =<span style="color: #000000;"> getClassMethods(cls);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">把所有的方法放入conflictingGetters中，key为属性名，value为List&lt;Method&gt;</span>
    <span style="color: #0000ff;">for</span><span style="color: #000000;"> (Method method : methods) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">方法的参数大于0，则结束本次循环，因为这里解析的是get方法，get方法默认不应该有参数</span>
      <span style="color: #0000ff;">if</span> (method.getParameterTypes().length &gt; 0<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
      }
      String name </span>=<span style="color: #000000;"> method.getName();
      </span><span style="color: #008000;">//</span><span style="color: #008000;">如果以get或is开头，且方法名称分别大于3和2，则说明是get方法</span>
      <span style="color: #0000ff;">if</span> ((name.startsWith("get") &amp;&amp; name.length() &gt; 3<span style="color: #000000;">)
          </span>|| (name.startsWith("is") &amp;&amp; name.length() &gt; 2<span style="color: #000000;">)) {
          </span><span style="color: #008000;">//</span><span style="color: #008000;">通过方法名转化为属性名，如，getUserName--userName</span>
        name =<span style="color: #000000;"> PropertyNamer.methodToProperty(name);
        
        addMethodConflict(conflictingGetters, name, method);
      }
    }<br /></span></pre>
<p>&nbsp; &nbsp; &nbsp; &nbsp; /**处理一个属性多个get方法的情况，即conflictingGetter方法中一个key对应的value的长度大于1的情况，如下<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*key propertyName<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*value list&lt;Method&gt; 其长度大于1 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/&nbsp;</p>
<p><span>&nbsp; &nbsp; &nbsp; &nbsp; resolveGetterConflicts(conflictingGetters);</span></p>
<pre><em id="__mceDel"><span style="color: #000000;">  }</span></em></pre>
</div>
<p>获取所有以get和is开头的方法，调用addMethodConflict方法，这里的方法名直译过来是添加冲突的方法，这里冲突怎么理解，我们看addMethodConflict方法，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> addMethodConflict(Map&lt;String, List&lt;Method&gt;&gt;<span style="color: #000000;"> conflictingMethods, String name, Method method) {
      </span><span style="color: #008000;">//</span><span style="color: #008000;">根据字段名取方法</span>
    List&lt;Method&gt; list =<span style="color: #000000;"> conflictingMethods.get(name);
    </span><span style="color: #0000ff;">if</span> (list == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
      list </span>= <span style="color: #0000ff;">new</span> ArrayList&lt;Method&gt;<span style="color: #000000;">();
      conflictingMethods.put(name, list);
    }
    list.add(method);
  }</span></pre>
</div>
<p>这里是根据get和is开头的方法获取属性名作为键值，并且使用list作为value进行存储，为什么使用list那，我们看下面的方法</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> getUser(){}
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> User getuser(){}
</span><span style="color: #0000ff;">public</span> List&lt;User&gt; getUser(){}<br />public void getUser(String id){}</pre>
</div>
<p>上面三个方法都会以user为键进行存储，但是其方法名是一样的，所以这里要存储为list，即存储多个Method对象。</p>
<p>我们知道一个字段的属性的get或set方法，不可能出现上面的情况，所以针对上面的情况需要做处理，这里调用resolveGetterConflicts(conflicttingGetters)，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> resolveGetterConflicts(Map&lt;String, List&lt;Method&gt;&gt;<span style="color: #000000;"> conflictingGetters) {
      </span><span style="color: #008000;">//</span><span style="color: #008000;">遍历conflictingGetters</span>
    <span style="color: #0000ff;">for</span> (Entry&lt;String, List&lt;Method&gt;&gt;<span style="color: #000000;"> entry : conflictingGetters.entrySet()) {
      Method winner </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
      String propName </span>=<span style="color: #000000;"> entry.getKey();
      </span><span style="color: #008000;">//</span><span style="color: #008000;">循环value这里value是一个List&lt;Method&gt;类型</span>
      <span style="color: #0000ff;">for</span><span style="color: #000000;"> (Method candidate : entry.getValue()) {
        </span><span style="color: #0000ff;">if</span> (winner == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
          winner </span>=<span style="color: #000000;"> candidate;
          </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获得get方法的返回值类型</span>
        Class&lt;?&gt; winnerType =<span style="color: #000000;"> winner.getReturnType();
        Class</span>&lt;?&gt; candidateType =<span style="color: #000000;"> candidate.getReturnType();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果winnerType和candidateType相等，</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (candidateType.equals(winnerType)) {
          </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">boolean</span>.<span style="color: #0000ff;">class</span><span style="color: #000000;">.equals(candidateType)) {
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ReflectionException(
                </span>"Illegal overloaded getter method with ambiguous type for property "
                    + propName + " in class " +<span style="color: #000000;"> winner.getDeclaringClass()
                    </span>+ ". This breaks the JavaBeans specification and can cause unpredictable results."<span style="color: #000000;">);
          } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (candidate.getName().startsWith("is"<span style="color: #000000;">)) {
            winner </span>=<span style="color: #000000;"> candidate;
          }
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (candidateType.isAssignableFrom(winnerType)) {
          </span><span style="color: #008000;">//</span><span style="color: #008000;"> OK getter type is descendant</span>
        } <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (winnerType.isAssignableFrom(candidateType)) {
          winner </span>=<span style="color: #000000;"> candidate;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
          </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ReflectionException(
              </span>"Illegal overloaded getter method with ambiguous type for property "
                  + propName + " in class " +<span style="color: #000000;"> winner.getDeclaringClass()
                  </span>+ ". This breaks the JavaBeans specification and can cause unpredictable results."<span style="color: #000000;">);
        }
      }
      addGetMethod(propName, winner);
    }
  }</span></pre>
</div>
<p>上面的方法处理了上面提到的一个属性存在多个get方法的情况，最后调用addGetMethod方法，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> addGetMethod(String name, Method method) {
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (isValidPropertyName(name)) {
      getMethods.put(name, </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> MethodInvoker(method));
      Type returnType </span>=<span style="color: #000000;"> TypeParameterResolver.resolveReturnType(method, type);
      getTypes.put(name, typeToClass(returnType));
    }
  }</span></pre>
</div>
<p>上面的方法把信息放到了getMethods和getTyps中，分别存储了get方法和返回值。</p>
<p>&nbsp;</p>
<p>上面分析了Reflector中的addGetMethods方法，addSetMethods方法和其处理过程类似，最终把set方法和返回值放到了setMethods和setTypes中。</p>
<p>addFileds(clazz)方法即是处理clazz中的属性，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> addFields(Class&lt;?&gt;<span style="color: #000000;"> clazz) {
    Field[] fields </span>=<span style="color: #000000;"> clazz.getDeclaredFields();
    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Field field : fields) {
      </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (canAccessPrivateMethods()) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
          field.setAccessible(</span><span style="color: #0000ff;">true</span><span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {
          </span><span style="color: #008000;">//</span><span style="color: #008000;"> Ignored. This is only a final precaution, nothing we can do.</span>
<span style="color: #000000;">        }
      }
      </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (field.isAccessible()) {
          </span><span style="color: #008000;">//</span><span style="color: #008000;">检查是否存在set方法，如果不存在添加该field</span>
        <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">setMethods.containsKey(field.getName())) {
          </span><span style="color: #008000;">//</span><span style="color: #008000;"> issue #379 - removed the check for final because JDK 1.5 allows
          </span><span style="color: #008000;">//</span><span style="color: #008000;"> modification of final fields through reflection (JSR-133). (JGB)
          </span><span style="color: #008000;">//</span><span style="color: #008000;"> pr #16 - final static can only be set by the classloader</span>
          <span style="color: #0000ff;">int</span> modifiers =<span style="color: #000000;"> field.getModifiers();
          </span><span style="color: #0000ff;">if</span> (!(Modifier.isFinal(modifiers) &amp;&amp;<span style="color: #000000;"> Modifier.isStatic(modifiers))) {
            addSetField(field);
          }
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">检查是否存在get方法，如果不存在添加该field</span>
        <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">getMethods.containsKey(field.getName())) {
          addGetField(field);
        }
      }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">添加父类的field</span>
    <span style="color: #0000ff;">if</span> (clazz.getSuperclass() != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
      addFields(clazz.getSuperclass());
    }
  }</span></pre>
</div>
<p>获得field之后，判断是否在getMethods和setMethods中，如果不在则进行添加，只看addSetField方法，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> addSetField(Field field) {
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (isValidPropertyName(field.getName())) {
      setMethods.put(field.getName(), </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> SetFieldInvoker(field));
      Type fieldType </span>=<span style="color: #000000;"> TypeParameterResolver.resolveFieldType(field, type);
      setTypes.put(field.getName(), typeToClass(fieldType));
    }
  }</span></pre>
</div>
<p>从上面看到如果一个field不存在set方法，则生成一个SetFieldInvoker把该对象放入setMethods，从这里可以看出一个setting配置的name值在configuration中可以没有set方法。同理也可以没有get方法。</p>
<p>&nbsp;</p>
<p>上面分析完了settingsAsProperties方法中的下面这行代码，</p>
<div class="cnblogs_code">
<pre>MetaClass metaConfig = MetaClass.forClass(Configuration.<span style="color: #0000ff;">class</span>, localReflectorFactory);</pre>
</div>
<p>把Configuration中的构造方法、get方法、set方法、field放入了metaConfig中的reflector对象中的下列属性</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> String[] readablePropertyNames;
  </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> String[] writeablePropertyNames;
  </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> Map&lt;String, Invoker&gt; setMethods = <span style="color: #0000ff;">new</span> HashMap&lt;String, Invoker&gt;<span style="color: #000000;">();
  </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> Map&lt;String, Invoker&gt; getMethods = <span style="color: #0000ff;">new</span> HashMap&lt;String, Invoker&gt;<span style="color: #000000;">();
  </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span style="color: #0000ff;">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;<span style="color: #000000;">();
  </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span style="color: #0000ff;">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;<span style="color: #000000;">();
  </span><span style="color: #0000ff;">private</span> Constructor&lt;?&gt; defaultConstructor;</pre>
</div>
<h3>2.2、校验配置的setting标签中的name是否存在</h3>
<p>上面分析完了MetaClass.forClass方法，下面看如何对setting标签配置的name进行校验</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Object key : props.keySet()) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">从metaConfig的relector中的setMethods中判断是否存在该属性，setMethods中存储的是可写的属性，
        </span><span style="color: #008000;">//</span><span style="color: #008000;">所以这里要到setMethods中进行判断</span>
      <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">metaConfig.hasSetter(String.valueOf(key))) {
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> BuilderException("The setting " + key + " is not known.  Make sure you spelled it correctly (case sensitive)."<span style="color: #000000;">);
      }
    }</span></pre>
</div>
<p>遍历从setting标签解析出来的Properties对象，调用metaConfig.hasSetter方法，</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> hasSetter(String name) {
    PropertyTokenizer prop </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> PropertyTokenizer(name);
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (prop.hasNext()) {
      </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (reflector.hasSetter(prop.getName())) {
        MetaClass metaProp </span>=<span style="color: #000000;"> metaClassForProperty(prop.getName());
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> metaProp.hasSetter(prop.getChildren());
      } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
      }
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> reflector.hasSetter(prop.getName());
    }
  }</span></pre>
</div>
<p>看hasSetter的定义</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> hasSetter(String propertyName) {
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> setMethods.keySet().contains(propertyName);
  }</span></pre>
</div>
<p>可以看到是判断setMethods是否存在该key，也就是已set方法为表标准，只要在setMethods中，便可以在&lt;setting&gt;标签的name中配置，具体配置值还需要看其类型。</p>
<h1>三、总结</h1>
<p>上面分析了mybatis的核心配置文件中&lt;settings&gt;标签的解析及子标签中name属性的配置值是怎么取的。如果要扩展核心文件配置中的setting标签的name属性值，需要在configuration中进行配置，及其他操作。</p>
<p>&nbsp;</p>
<p>原创不易，有不正之处欢迎指正。</p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2020-04-22 17:51</span>&nbsp;
<a href="https://www.cnblogs.com/teach/">迷茫中守候</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12753756" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12753756);return false;">收藏</a></div>
        </div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 293786, cb_blogApp = 'teach', cb_blogUserGuid = 'c7cf8dfe-a93e-e611-9fc1-ac853d9f53cc';
    var cb_entryId = 12753756, cb_entryCreatedDate = '2020-04-22 17:51', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>    </div>
</div>
            </div>
        </div>

        <div id="sideBar">
            <div id="sideBarMain">
                
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

                <div id="calendar"><div id="blog-calendar" style="display:none"></div></div>                
                <script>loadBlogDefaultCalendar();</script>
                <div id="leftcontentcontainer">
                    <!-- begin:SingleColumn -->
                    <div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
                    <!-- end:  SingleColumn -->
                </div>
            </div>
        </div>
        <div class="clear"></div>
    </div>
    <div class="clear"></div>
    <div id="footer">
        <!--done-->
Copyright &copy; 2020 迷茫中守候
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>

    </div>
</div>

    
</body>
</html>