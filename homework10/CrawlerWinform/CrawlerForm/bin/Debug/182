<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta property="og:description" content="前言 智慧楼宇和人们的生活息息相关，楼宇智能化程度的提高，会极大程度的改善人们的生活品质，在当前工业互联网大背景下受到很大关注。目前智慧楼宇可视化监控的主要优点包括: 智慧化&amp;#160;-- 智慧楼宇" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>新基建的福音：智慧楼宇可视化监控系统引领智能化新时代 - xhload3d - 博客园</title>
    <link rel="shortcut icon" href="//common.cnblogs.com/favicon.ico?v=20200522" type="image/x-icon" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=KCO3_f2W_TC__-jZ7phSnmoFkQuWMJH2yAgA16eE3eY" />
    <link id="MainCss" rel="stylesheet" href="/skins/cogitation/bundle-cogitation.min.css?v=PJ48NAY_dmbjZZ0ZTev3Avl3BcTMJe39d3Pc83CPcig" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/cogitation/bundle-cogitation-mobile.min.css?v=jLHKTG0H_smj72y-Z2j0JGYUmhBVGTu4_QpAGb1B_sA" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/xhload3d/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/xhload3d/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/xhload3d/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=6bwfCY2e02dLOXNW99G2BHZkYFmw9QyYTWeJ-W-sudo"></script>
    <script>
        var currentBlogId = 171723;
        var currentBlogApp = 'xhload3d';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'Cogitation';
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    
    <div id="top">
	
<div>
	<table>
		<tr>
			<td class="HeaderTitles">
				<h1 class="HeaderTitle"><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/xhload3d/">xhload3d</a>
</h1>
				<p id="tagline">
www.hightopo.com
</p>
			</td>
		</tr>
	</table>
</div>
<div class="HeaderBar">
	<table id="HeaderBar" class="HeaderBar" cellpadding="0" cellspacing="0">
		<tr>
			<td class="HeaderBarTab" nowrap>
&nbsp;
<a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
 ::

<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/xhload3d/">
首页</a>
 ::
<a href="http://q.cnblogs.com" class="menu">博问</a> ::
<a href="http://home.cnblogs.com/ing/" class="menu">闪存</a> ::


<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
 ::

<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/xhload3d">
联系</a> ::

<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/xhload3d/rss/">
订阅</a>

<a id="blog_nav_rss_image" href="https://www.cnblogs.com/xhload3d/rss/">
    <img src="/skins/cogitation/images/xml.gif" alt="订阅" />
</a> ::

<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
 ::


</td>
			<td><img id="Header1_BlueTab" src="/skins/cogitation/images/BlueTabRight.gif" align="absmiddle" alt=""/></td>
			<td class="HeaderBarTabBack" nowrap width="100%">
				<div class="BlogStatsBar">
	<table class="BlogStatsBar">
		<tr>
			<td width="100%">
			</td>
			<td class="BlogStatsBar" nowrap>
				&nbsp;
				
243 
				随笔&nbsp;::
				
1 文章
				::
				
431 评论
				::
				
0 引用
			</td>
		</tr>
	</table>
</div>


			</td>
		</tr>
	</table>
</div>


</div>
<div id="leftmenu">	

	    <div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
		
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

<div id="sidebar_ad"></div>
		<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
	
</div>
<div id="main">
	<div id="post_detail">
<div class="post">
	<div class="postTitle">
		
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/xhload3d/p/12973149.html">新基建的福音：智慧楼宇可视化监控系统引领智能化新时代</a>

	</div>
	
	<div class="postText">
		
    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2018.cnblogs.com/blog/591709/201902/591709-20190201143151913-1819448404.gif" class="desc_img"> 智慧楼宇和人们的生活息息相关，楼宇智能化程度的提高，会极大程度的改善人们的生活品质，在当前工业互联网大背景下受到很大关注。传统的 智慧楼宇/楼宇自动化/楼宇安防/智慧园区 常会采用 BIM（建筑信息模型 Building information modeling）软件，如 Autodesk 的 Revit 或 Bentley 这类建筑和工程软件，但这些 BIM 建模模型的数据往往过于庞大臃肿，绝大部分细节信息对楼宇自控意义不大，反而影响拖累了行业 Web SCADA 或 Web 组态监控的趋势，所以我们采用以 Hightopo 的 HT for Web 产品轻量化 HTML5/WebGL 建模的方案，实现快速建模、运行时轻量化到甚至手机终端浏览器即可 3D 可视化运维的良好效果。
    </div>
<div id="cnblogs_post_body" class="blogpost-body ">
    <p><span data-mce-=""><strong>前言</strong></span></p>
<p>智慧楼宇和人们的生活息息相关，楼宇智能化程度的提高，会极大程度的改善人们的生活品质，在当前<strong>工业互联网</strong>大背景下受到很大关注。目前<strong>智慧楼宇可视化监控</strong>的主要优点包括:</p>
<ul>
<li><strong>智慧化</strong>&nbsp;-- 智慧楼宇是一个生态系统，像人一样拥有感知能力、自我判断能力以及控制能力。</li>
<li><strong>绿色化</strong>&nbsp;-- 绿色建筑在耗能、产能以及能源管理方面实现绿色化，楼宇安防实现绿色化监控。</li>
<li><strong>运行成本可控制</strong>&nbsp;-- 基于可持续发展的要求，现代建筑、商业建筑需运行50年以上，建筑在运行过程中能源消耗巨大，如何降低运营成本降低，使建筑在低碳、环保的状态下健康运行。</li>
</ul>
<p>衣食住行往往是不可或缺，而楼宇建设一直是社会发展进步的一块基点。以往的管理方式，需要细致地划分各个模块的实施，但各个模块又相对独立，在管理成本上和人力投入上都耗费了许多的精力。现如今在科技日益发展的道路上，我们历经了<strong>工业互联网</strong>的浪潮，又顺应了&nbsp;<strong>5G 新时代、新基建</strong>的发展，<strong>工业4.0&nbsp;</strong>不单势在必行，而是已经步步落实。通过技术发展的经验总结，我们可以在互联网实施多样化行业可视化系统监控管理方案，智慧楼宇可视化系统亦是如此，通过一套完备的子系统串联，整理出可视化在线管理系统的集合，极大提升了管理能力和节省劳动力的投入。</p>
<p><img src="https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200525171354529-978231212.png" alt="" width="797" height="393"></p>
<p>传统的 智慧楼宇/楼宇自动化/楼宇安防/智慧园区 常会采用 BIM（建筑信息模型 Building information modeling）软件，如 Autodesk 的 Revit 或 Bentley 这类建筑和工程软件，但这些 BIM 建模模型的数据往往过于庞大臃肿，绝大部分细节信息对楼宇自控意义不大，反而影响拖累了行业&nbsp;<strong>Web SCADA</strong>&nbsp;或&nbsp;<strong>Web 组态</strong>监控的趋势，所以我们采用以&nbsp;<strong>Hightopo</strong>&nbsp;的&nbsp;<strong>HT for Web</strong>&nbsp;产品轻量化 HTML5/WebGL 建模的方案，实现快速建模、运行时轻量化到甚至手机终端浏览器即可 3D 可视化运维的良好效果。</p>
<p>本篇文章通过对智能建筑的建模，页面动画效果的实现，以及页面主要功能点进行阐述，帮助我们了解如何使用&nbsp;<a title="HT" href="https://hightopo.com/" target="_blank">HT</a>&nbsp;实现一个简单的智慧楼宇可视化监控，以及帮助我们了解智慧楼宇，楼宇自动化的优势。</p>
<p>预览地址：<a title="基于 HTML5 的 WebGL 楼宇自控 3D 可视化监控" href="http://www.hightopo.com/demo/ht-smart-building/" target="_blank">基于 HTML5 的 WebGL 楼宇自控 3D 可视化监控</a>&nbsp;<a href="http://www.hightopo.com/demo/ht-smart-building/" target="_blank">http://www.hightopo.com/demo/ht-smart-building/</a></p>
<p><span data-mce-=""><strong>界面简介及效果预览</strong></span></p>
<p>界面通过 2d 图纸叠加在 3d 场景上来实现 2d 界面 与 3d 场景的融合，2d 界面通过自动布局的机制实现了手机端与电脑端的响应式呈现。</p>
<p><span data-mce-=""><strong>界面初始化效果</strong></span></p>
<p><img src="https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200525153633017-1382323312.gif" alt=""></p>
<p>界面初始化过程中的动画包括地面路径的实时渲染，楼层的展开，楼层的辉光扫描，楼层报警点动态水波，楼层监测数据面板的实时变化等等。</p>
<p><span data-mce-=""><strong>监控界面效果</strong></span></p>
<p><img src="https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200525155139817-617555084.gif" alt=""></p>
<p><strong>监控界面包括：</strong></p>
<ol>
<li>人员进入大厦的实时监控，面板中动态刷新人员进入大厦的头像以及当前大厦人数等实时信息。</li>
<li>大厦电梯运行情况实时监控，系统中展示电梯当前的运行位置以及是否在运行等信息。</li>
<li>大厦某个具体楼层监控数据的实时监控，通过柱状图的形式展示了当前楼层具体信息的大小。</li>
<li>大厦管道的实时监控，展示了当前智能建筑所有管道的运行情况。</li>
</ol>
<p><strong>智能建筑建模</strong></p>
<p>该 3d 场景中所有的模型均为线段和六面体搭建，相比较通过 3d Max 建模然后通过 obj 导入来说场景中的三角面会少很多，更加的轻量化，例如场景中建筑的楼层，通过&nbsp;<strong>ht.Shape</strong>&nbsp;类绘制，该类中记录着楼层&nbsp;<strong>points</strong>&nbsp;点的信息以及&nbsp;<strong>segments</strong>&nbsp;为&nbsp;<strong>ht.List</strong>&nbsp;类型的线段数组信息，<strong>segments</strong>&nbsp;代表着点的连接方式，用于告诉&nbsp;<strong>ht.Shape</strong>&nbsp;利用点的信息来绘制二次贝塞尔曲线或者三次贝塞尔曲线或者直线等信息，相关具体说明请参考 HT for Web 的<a href="http://www.hightopo.com/guide/guide/core/shape/ht-shape-guide.html" target="_blank">[形状手册]</a>，以下为绘制单层的截图：</p>
<p><img src="https://img2018.cnblogs.com/blog/591709/201902/591709-20190201143743362-380396194.jpg" alt="" width="800" height="308"></p>
<p>通过上图可以知道构建完一层模型之后其它几层模型均为相同的，只是 y 轴的数值不同，通过叠加几层之后便可形成一幢大楼的轮廓。如果用户需要搭建智慧园区，智慧楼宇等场景，完全可以使用这种基于 HTML5/WebGL 建模的方案，减少考虑使用 BIM 建模模型。场景中的管道以及背景地图路线都为点连线之后构成，只是通过修改线的颜色粗细或者进行贴图来修改线或者面的样式，场景中的电梯为一个颜色为黄色的简单六面体，电梯线也为一条线段而已，所以场景中的模型都是轻量化的建模，使 3d 场景运行渲染的更加流畅，提升用户体验。</p>
<p><span data-mce-=""><strong>场景关键动画代码分析</strong></span></p>
<p><span data-mce-=""><strong>1. 地图路线动画代码分析</strong></span></p>
<p>通过上述<strong>智能建筑建模</strong>的分析我们可以知道线路都是为点与点之间进行连线而生成，所以当我们绘制完地图的路径之后可以得到所有点的信息，假如直线&nbsp;<strong>AB</strong>&nbsp;为地图中的某一条线段，那么我们可以知道点&nbsp;<strong>A</strong>&nbsp;以及点&nbsp;<strong>B</strong>&nbsp;的点的坐标，之后我们可以计算&nbsp;<strong>AB</strong>&nbsp;线段上任意一点&nbsp;<strong>C</strong>&nbsp;的点的坐标，然后通过连接&nbsp;<strong>A</strong>&nbsp;点与&nbsp;<strong>C</strong>&nbsp;点来形成一条与&nbsp;<strong>AB</strong>&nbsp;线段位置方向相同但是大小比&nbsp;<strong>AB</strong>&nbsp;线段短的线，直到&nbsp;<strong>AC</strong>&nbsp;线段的长度等于&nbsp;<strong>AB</strong>&nbsp;线段长度之后再进行下一条路径动画的绘制，以下为关键伪代码展示：</p>
<div class="cnblogs_code">
<pre><span data-mce-="">//<span data-mce-=""> currentIndex 为当前路径绘制到的点的索引 <span data-mce-="">
//<span data-mce-=""> points 为当前路径所有点的信息  currentPoints 为绘制过程中点的信息 <span data-mce-="">
//<span data-mce-=""> segments 为当前路径所有点的连接方式信息 currentSegments 为绘制过程中点的连接方式信息

<span data-mce-="">//<span data-mce-=""> 即上述此时 A 点信息
let fromPoint =<span data-mce-=""> points[currentIndex]; 
<span data-mce-="">//<span data-mce-=""> 即上述此时 B 点信息
let toPoint = points[currentIndex + 1<span data-mce-="">]; 
<span data-mce-="">//<span data-mce-=""> 通过 AB 两点信息组成一条 AB 方向的向量
let pointVector = <span data-mce-="">new ht.Math.Vector2(toPoint.x - fromPoint.x, toPoint.y -<span data-mce-=""> fromPoint.y); 
<span data-mce-="">//<span data-mce-=""> 记录该向量的长度，用于判断 AC 是否大于等于 AB
let pointVectorLength =<span data-mce-=""> pointVector.length(); 

let currentPoints = [], currentSegments =<span data-mce-=""> [];

<span data-mce-="">for(let i = 0; i &lt; currentIndex + 1; i++<span data-mce-="">) {
    currentPoints.push({
      x: points[i].x,
      y: points[i].y
    });
    currentSegments.push(segments[i]);
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p>通过上述代码可以知道我们获取到了 currentPoints 以及 currentSegments 的信息了，之后便要计算在 fromPoint(A点) 与 toPoint(B点) 连线上点的坐标，即 C 点，以下为计算 C 点的关键伪代码：</p>
<div class="cnblogs_code">
<pre><span data-mce-="">//<span data-mce-=""> addLength 为每次增加的线段长度值，该程序中使用 500 即每次长度增加 500
let nextVectorLength = currentVectorLength +<span data-mce-=""> addLength;
let tempPoint;
    
roadData.currentVectorLength =<span data-mce-=""> nextVectorLength;

<span data-mce-="">//<span data-mce-=""> 判断 AC 线段的长度是否大于 AB 
<span data-mce-="">if(nextVectorLength &gt;<span data-mce-=""> pointVectorLength) {
    nextVectorLength =<span data-mce-=""> pointVectorLength;
    roadData.currentVectorLength = 0<span data-mce-="">;
    roadData.currentIndex = currentIndex + 1<span data-mce-="">;
}

pointVector.setLength(nextVectorLength);

<span data-mce-="">//<span data-mce-=""> 即为 C 点坐标
tempPoint = {x: pointVector.x + fromPoint.x, y: pointVector.y +<span data-mce-=""> fromPoint.y}; 
<span data-mce-="">//<span data-mce-=""> 往 currentPoints 添加 C 点坐标
<span data-mce-="">currentPoints.push(tempPoint); 
<span data-mce-="">//<span data-mce-=""> 往 currentSegments 添加 C 点连接方式，此程序中都为直线连接，所以值都为 2
currentSegments.push(2<span data-mce-="">); 
<span data-mce-="">//<span data-mce-=""> roadNode 即为 ht.Shape 类 重新设置 ht.Shape 类点的信息
<span data-mce-="">roadNode.setPoints(currentPoints);  
<span data-mce-="">//<span data-mce-=""> 重新设置 ht.Shape 类点的连接信息
roadNode.setSegments(currentSegments); </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p>以下为动画代码执行流程图</p>
<p><img src="https://img2018.cnblogs.com/blog/591709/201902/591709-20190201143304528-941131602.jpg" alt=""></p>
<p>以下为绘制一条路线动画的截图：</p>
<p><img src="https://img2018.cnblogs.com/blog/591709/201902/591709-20190201143324316-51398477.gif" alt="" width="798" height="413"></p>
<p>程序中通过<strong>向量</strong>的计算方式来不断获取&nbsp;<strong>C</strong>&nbsp;点的坐标，当然也可以用其它方式来计算&nbsp;<strong>C</strong>&nbsp;点的坐标。</p>
<p>&nbsp;</p>
<p><span data-mce-=""><strong>2. 水波以及扫描动画代码分析</strong></span></p>
<p><img src="https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200525155907273-1671787350.gif" alt=""></p>
<p>水波以及扫描动画都是通过&nbsp;<strong>HT</strong>&nbsp;提供的修改图标矩形框信息 api 来进行控制，通过调度的方式不断修改图标矩形框大小来产生水波以及扫描的动画效果，<strong>调度</strong>的具体用法可以参考 HT for Web 的<a href="http://www.hightopo.com/guide/guide/core/schedule/ht-schedule-guide.html" target="_blank">[调度手册]</a>，以下为水波动画的关键伪代码：</p>
<div class="cnblogs_code">
<pre><span data-mce-="">//<span data-mce-=""> waterWaveNodes 所有水波节点
let waterWaveTask =<span data-mce-=""> {
    interval: 100, <span data-mce-="">//<span data-mce-=""> 指每隔 100 ms 调用 action 函数一次
    action: <span data-mce-="">function<span data-mce-="">(data){
        <span data-mce-="">//<span data-mce-=""> 判断 waterWaveNodes 是包含 data
        <span data-mce-="">if(waterWaveNodes.indexOf(data) &gt; -1<span data-mce-="">) { 
            <span data-mce-="">//<span data-mce-=""> 获取此时图标矩形框信息 circleRect 是个长度为 4 的数组 分别表示 x, y, width, height
            let circleRect = data.a('circleRect'<span data-mce-="">);   
            <span data-mce-="">if<span data-mce-="">(circleRect) {
                <span data-mce-="">//<span data-mce-=""> 通过修改高度来变大水波大小
                let nextHeight = circleRect[3] + 10<span data-mce-="">;                 
                <span data-mce-="">//<span data-mce-=""> 高度最大值为 250 
                <span data-mce-="">if(nextHeight &lt; 250<span data-mce-="">) { 
                     <span data-mce-="">//<span data-mce-=""> 对应修改 y 的大小，y 的增加大小为高度的一半
                    circleRect[1] = circleRect[1] - 5<span data-mce-="">;
                    circleRect[3] =<span data-mce-=""> nextHeight;
                    data.a('circleRect'<span data-mce-="">, circleRect);
                    data.a('borderColor', 'rgba(255, 133, 133, ' + (1 - circleRect[3] / 250) + ')'<span data-mce-="">);
                }
                <span data-mce-="">else<span data-mce-=""> {
                    data.a('circleRect', [-0.5,128,257,0<span data-mce-="">]);
                    data.a('borderColor', 'rgba(255, 133, 133)'<span data-mce-="">);
                }            
            }
            <span data-mce-="">else<span data-mce-=""> {
                data.a('circleRect', [-0.5,128,257,0<span data-mce-="">]);
            }           
        }
    }    
};
<span data-mce-="">//<span data-mce-=""> 新增该调度任务
dm3d.addScheduleTask(waterWaveTask); </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p>下图为水波在 2d 中的截图：</p>
<p><img src="https://img2018.cnblogs.com/blog/591709/201902/591709-20190201143334553-266741100.gif" alt=""></p>
<p>&nbsp;</p>
<p><span data-mce-=""><strong>3. 数字变化动画代码分析</strong></span></p>
<p>从程序的截图中可以看到在 2d 面板以及 3d 场景中都有数字在动态的变化，这部分主要通过数据绑定动态来修改数值的大小，关于数据绑定可以参考 HT for Web 的<a href="http://www.hightopo.com/guide/guide/core/databinding/ht-databinding-guide.html" target="_blank">[数据绑定手册]</a>，也是通过调度来不断修改数值的大小，程序中我封装了产生随机数的代码，用于每次产生随机数之后绑定到对应的节点上，以下为修改 2d 面板上数字的变化伪代码：</p>
<div class="cnblogs_code">
<pre><span data-mce-="">//<span data-mce-=""> numNode(1-7) 为 2d 面板中对应数字的节点<span data-mce-="">
//<span data-mce-=""> data.a('ht.value', number) 即为动态修改 attr 上的 ht.value 信息，之后图纸会自动更新新赋予的数值<span data-mce-="">
//<span data-mce-=""> getRandomValue 为自己封装的产生随机数的方法
<span data-mce-="">this.change2dNumTask =<span data-mce-=""> {
        interval: 1000<span data-mce-="">,
        action: (data) =&gt;<span data-mce-=""> {
            <span data-mce-="">if(data === numNode1 || data ===<span data-mce-=""> numNode2) {
                data.a('ht.value', util.getRandomValue([500, 999], 5<span data-mce-="">));
            }
            <span data-mce-="">if(data === numNode3 || data ===<span data-mce-=""> numNode4) {
                data.s('text', util.getRandomValue([0, 30], 2) + '%'<span data-mce-="">);
            }
            <span data-mce-="">if(data ===<span data-mce-=""> numNode5) {
                data.a('ht.value', util.getRandomValue([0, 99999], 5, 3<span data-mce-="">));
            }
            <span data-mce-="">if(data ===<span data-mce-=""> numNode6) {
                data.a('ht.value', util.getRandomValue([0, 100], 2<span data-mce-="">));
            }
            <span data-mce-="">if(data ===<span data-mce-=""> numNode7) {
                data.a('ht.value', util.getRandomValue([0, 100], 2<span data-mce-="">));
            }
       }        
    };
<span data-mce-="">//<span data-mce-=""> 新增该调度任务
dm2d.addScheduleTask(<span data-mce-="">this.change2dNumTask); </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>通过以上代码可以知道修改数值是通过修改节点的 attr 以及 style 对象的某个属性值来动态变化数值，当然在程序中 2d 面板可能还会隐藏，此时该调度任务就不需要执行，可以调用 removeScheduleTask 方法来移除此调度任务。</p>
<p>&nbsp;</p>
<p><span data-mce-=""><strong>4. 柱状图高度动画代码分析</strong></span></p>
<p><img src="https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200525160124248-680470070.gif" alt=""></p>
<p>在 3d 场景中柱状体也是一个六面体，只是四周用了渐变的贴图，以及顶面用了一张纯色的贴图构造出来，每个六面体都有高度的信息，<strong>HT</strong>&nbsp;中通过&nbsp;<strong>node.getTall()</strong>&nbsp;来获取当前六面体的高度值，根据上一节讲的数据绑定，我们可以在展示柱状图的时候循环获取所有柱状体节点的高度值大小假如命名为&nbsp;<strong>tall</strong>，之后通过&nbsp;<strong>node.a('tall', tall)</strong>&nbsp;将该值存储到当前柱状图节点的&nbsp;<strong>attr</strong>&nbsp;对象上面，之后在柱状体初始化的时候可以不断修改高度值来动态改变高度，当高度值大于&nbsp;<strong>node.a('tall')</strong>&nbsp;则说明当前柱状体初始化的高度已经完成。以下为相关的伪代码：</p>
<div class="cnblogs_code">
<pre>charts.forEach((chart) =&gt;<span data-mce-=""> {
    <span data-mce-="">//<span data-mce-=""> 将高度存储到 attr 上
    !chart.a('tall') &amp;&amp; chart.a('tall'<span data-mce-="">, chart.getTall()); 
    <span data-mce-="">//<span data-mce-=""> 设置初始高度为 0
    chart.setTall(0<span data-mce-="">); 
});
<span data-mce-="">this.chartAnimteTask =<span data-mce-=""> {
    interval: 25<span data-mce-="">,
    action: <span data-mce-="">function<span data-mce-="">(data){
        <span data-mce-="">if(charts.indexOf(data) &gt; -1<span data-mce-="">) {
            <span data-mce-="">if(finishNum !==<span data-mce-=""> chartLength) {
                <span data-mce-="">if(data.getTall() !== data.a('tall'<span data-mce-="">)) {
                    <span data-mce-="">//<span data-mce-=""> deep 为每次增加的高度
                    let nextTall = data.getTall() +<span data-mce-=""> deep; 
                    <span data-mce-="">//<span data-mce-=""> 获取初始化高度 
                    let tall = data.a('tall'<span data-mce-="">); 
                    <span data-mce-="">//<span data-mce-=""> 判断下一个高度是否大于初始化高度
                    <span data-mce-="">if(nextTall &lt;<span data-mce-=""> tall) {
                        data.setTall(nextTall);
                    }
                    <span data-mce-="">else<span data-mce-=""> {
                        data.setTall(tall);
                        finishNum++<span data-mce-="">;
                    }
                }    
            }
        }
    }    
};
<span data-mce-="">//<span data-mce-=""> 新增该调度任务
dm3d.addScheduleTask(<span data-mce-="">this.chartAnimteTask); </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>通过上面代码可以知道动画每一步的程序执行也是通过调度来完成的，与前文几个动画的实现方式类似。</p>
<p>&nbsp;</p>
<p><span data-mce-=""><strong>5. 3d 镜头推进代码分析</strong></span></p>
<p>3d 场景中视野的推进后退都是通过 HT api 提供的修改&nbsp;<strong>eye</strong>&nbsp;以及&nbsp;<strong>center</strong>&nbsp;的数值方法来实现，通过不断调用 setEye 以及 setCenter 方法来达到修改视角的目的，eye 类比人眼睛所处的位置，center 类比人眼睛聚焦的位置，以下为实现镜头推进关键的伪代码：</p>
<div class="cnblogs_code">
<pre>let e = ht.Default.clone(g3d.getEye()), <span data-mce-="">//<span data-mce-=""> 获取当前眼睛的位置
    c = ht.Default.clone(g3d.getCenter()); <span data-mce-="">//<span data-mce-=""> 获取当前眼睛聚焦的位置<span data-mce-="">
//<span data-mce-=""> eye 为需要修改的对应 eye 值<span data-mce-="">
//<span data-mce-=""> center 为需要修改的对应 center 值<span data-mce-="">
//<span data-mce-=""> 以下为分别获取 eye 与 center 在 xyz 三个坐标轴之间的差值
let edx = eye[0] - e[0<span data-mce-="">],
    edz = eye[1] - e[1<span data-mce-="">],
    edy = eye[2] - e[2<span data-mce-="">],
    cdx = center[0] - c[0<span data-mce-="">],
    cdz = center[1] - c[1<span data-mce-="">],
    cdy = center[2] - c[2<span data-mce-="">];
<span data-mce-="">//<span data-mce-=""> 开启不断修改 eye 与 center 的动画
<span data-mce-="">ht.Default.startAnim({
    duration: time ? time : 3000<span data-mce-="">,
    easing: <span data-mce-="">function(t){ <span data-mce-="">return<span data-mce-=""> t; },
    finishFunc: <span data-mce-="">function<span data-mce-="">() {
        <span data-mce-="">if(<span data-mce-="">typeof cb === 'function'<span data-mce-="">) {
            cb();
        }
    },
    action: <span data-mce-="">function<span data-mce-=""> (v) {
        <span data-mce-="">//<span data-mce-=""> v 为从 0-1 变换的值 
<span data-mce-="">        g3d.setEye([
            e[0] + edx *<span data-mce-=""> v,
            e[1] + edz *<span data-mce-=""> v,
            e[2] + edy *<span data-mce-=""> v
        ]);
        g3d.setCenter([
            c[0] + cdx *<span data-mce-=""> v,
            c[1] + cdz *<span data-mce-=""> v,
            c[2] + cdy *<span data-mce-=""> v
        ]);
    }
});</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>通过以上代码可以知道通过修改 eye 与 center 分别对应的 xyz 轴的值与当前 e 与 c 分别对应的 xyz 轴的值之间的距离来达到视角的变化。</p>
<p>以下为该代码的一个应用截图:</p>
<p><img src="https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200525155449010-1253288990.gif" alt=""></p>
<p>&nbsp;</p>
<p><span data-mce-=""><strong>总结</strong></span></p>
<p><strong>物联网</strong>通过各种信息传感设备，实时采集任何需要监控、连接、互动的物体或过程等各种需要的信息，与互联网结合形成的一个巨大网络。实现了物与物、物与人，所有的物品与网络的连接，方便识别、管理和控制。所以物联网带给我们的<strong>智慧楼宇的可视化监控</strong>需要监控的方面可能还有很多，该系统中针对人员出入，设备信息，管道信息等的监控实现了一个简单的智慧楼宇监控系统，物联网也将用户端延伸和扩展到了任何物品与物品之间，让我们更加了解搭建智慧园区，智慧校园等场景监控之后设备可视化，资产可视化带给我们的直观性。场景中的反光与景深等效果都是 HT 核心包提供的效果，所有的模型搭建与动画也都是通过 HT 核心包提供的 api 进行建模与动画驱动，所以在网页中展示会十分流畅，大大提高了用户的体验，并且在移动端表现也十分友好。</p>
<p>以下为移动端的程序运行截图：</p>
<p><img src="https://img2018.cnblogs.com/blog/591709/201902/591709-20190201143403750-863048551.gif" alt=""></p>
<p>HT 通过在行业上不断地摸索和技术上的钻研提升，总结出了许多工业互联网上各个行业的解决方案，不仅可以在 PC 端展示出可视化监控系统，在移动端同样可以轻量型地展示出来。以下是另外一个<a href="https://www.hightopo.com/demo/smart-building-pc/" target="_blank">智慧楼宇的可视化监控系统</a>的实现效果：</p>
<p><img src="https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200525161315690-341121063.gif" alt=""></p>
<div>同样的，2019 我们也更新了数百个工业互联网 2D/3D 可视化案例集，在这里你能发现许多新奇的实例，也能发掘出不一样的工业互联网：<a href="https://mp.weixin.qq.com/s/ZbhB6LO2kBRPrRIfHlKGQA">https://mp.weixin.qq.com/s/ZbhB6LO2kBRPrRIfHlKGQA</a></div>
<div>同时，你也可以查看更多案例及效果：<a href="https://www.hightopo.com/demos/index.html">https://www.hightopo.com/demos/index.html</a></div>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
	</div>
	
	<div class="postfoot">
		posted on 
<span id="post-date">2020-05-27 23:58</span>&nbsp;
<a href="https://www.cnblogs.com/xhload3d/">xhload3d</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12973149" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12973149);return false;">收藏</a>
	</div>
</div>


<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 171723, cb_blogApp = 'xhload3d', cb_blogUserGuid = '99a30dc7-3165-e311-8d02-90b11c0b17d6';
    var cb_entryId = 12973149, cb_entryCreatedDate = '2020-05-27 23:58', cb_postType = 1; 
    loadViewCount(cb_entryId);
    loadSideColumnAd();
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;"></div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div></div>


</div>
<div class="footer">
<p id="footer">
	Powered by: 
	<br />
	
	<a href="https://www.cnblogs.com/" id="footer_site_link">博客园</a>
	<br />
	Copyright &copy; 2020 xhload3d
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>

</p>


</div>


    
</body>
</html>